% !TeX root = README.tex

\section{Getting Started Guide}

Our artifact is a program analysis tool with the following capabilities:
\begin{enumerate}
  \item Check structural type equality of (possibly context-free) guide types
  \item Infer guide types of model and guide programs (using the
  structural-type-equality checking algorithm)
  \item Check whether the support of sequentially composed guide programs
  coincides with the support of a model program.
\end{enumerate}

In probabilistic programming with our new coroutine-based
programmable inference framework, the user provides a model program and a
sequential composition of guide programs.
%
The model program specifies a probabilistic model for Bayesian inference.
%
The sequential composition of guide programs customizes the Block
Metropolis-Hastings (BMH) algorithm, where we successively run the guide
programs, each of which is followed by an MH acceptance routine.
%
Each guide program only updates a subset (i.e., block) of random variables.
%
The model and guide programs are coroutines that communicate with other by
message passing, and their communication protocols are described by guide types.
%
To algorithmically decide structural type equality of guide types, our artifact
implements the bisimilarity-checking algorithm by \citet{Hirshfeld1994} for
context-free processes with finite norms, which model guide types.
%
This structural-type-equality checking algorithm is also incorporated into the
type-inference algorithm for guide types.
%
Finally, to verify the soundness of the BMH algorithm, our artifact checks
whether the support of the sequentially composed guide programs covers all
traces all possible traces admitted by the model program.

The artifact is wrapped inside the accompanying Docker image
\texttt{guide\_types.tar.gz}.
%
Before running it, first install Docker as instructed here:
\url{https://docs.docker.com/engine/install/}.
%
To see if Docker has been installed properly, run
\begin{verbatim}
$ docker --version
Docker version 27.0.3, build 7d4bcd8
\end{verbatim}

Load a Docker image by running
\begin{verbatim}
$ docker load --input guide_types.tar.gz
\end{verbatim}
%
It creates an image named \texttt{guide\_types} and stores it locally on your
%
Docker may create an image with a slightly different name from
\texttt{guide\_types}.
%
To check the name of the image, display all Docker images on your local machine
by running
\begin{verbatim}
$ docker images
\end{verbatim}

To run the image \texttt{guide\_types}, run
\begin{verbatim}
$ docker run --name guide_types -it --rm guide_types
root@5b1c8c873064:/home/GuideTypes#
\end{verbatim}
%
It creates a Docker container (i.e., a runnable instance of the Docker image)
named \texttt{guide\_types} and starts a shell inside the container.
%
If the command does not run properly, you can instead build the image locally on
your machine as instructed in \cref{sec:Build the Docker Image}.

Throughout this document, any command line starting with \texttt{\#} is executed
inside the Docker container, and any command line starting with \texttt{\$} is
executed in your local machine's terminal.

\subsection{Structural-Type-Equality Checking}

The initial working directory \texttt{type-equality} contains a file
\texttt{type-equality-sample} storing several guide-type definitions.
%
To display the content of the file, we run
\begin{verbatim}
# cat type-equality-sample
\end{verbatim}
%
It prints out
\begin{verbatim}
type T1 = &{ $ | real /\ T1[T1] }
type T2 = &{ $ | real /\ T2[T2] }
type T3 = &{ $ | real /\ real /\ T3[T3] }
\end{verbatim}
%
The first line defines a guide-type operator $T_1 [\cdot]$ as
\begin{equation*}
  T_1 [X] \coloneq X \echoice (\treal \land \mathbb{R} \land T_1 [T_1[X]]),
\end{equation*}
where $X$ is a type variable that stands for a continuation type (i.e., the type
of the communication protocol that we run after $T_1$ is finished).
%
The type $T_1$ means the coroutine receives a branch selection (from another
coroutine that it communicates with), and proceeds to either $X$ (i.e., the
continuation guide type) or $\mathbb{R} \land T_1 [T_1[X]]$, depending on which
branch is taken.
%
The guide type $\mathbb{R} \land T_1 [T_1[X]]$ means the coroutine first sends a
message of type $\mathbb{R}$ (i.e., real numbers) and then proceeds to the guide type
$T_1 [T_1 [X]]$.
%
Here, $T_1 [T_1 [X]]$ can be interpreted as a sequential composition of two
instances of $T_1$, followed by the original continuation $X$.

To algorithmically decide the structural type equality between the guide-type
operators $T_1 [X]$ and $T_2 [X]$, run
\begin{verbatim}
# dune exec gtypes type-equality type-equality-sample T1 T2
\end{verbatim}
%
The command successfulyl determines that the two type operators are structurally
equal, as indicated by the following line towards the end of the command's
printout:
\begin{verbatim}
Types T1 and T2 are equal
\end{verbatim}
%
This is as expected because the two type operators $T_1 [X]$ and $T_2 [X]$
represent the same type---they only differ in the names of type operators.

Next, to check the structural type equality between $T_1 [X]$ and $T_3 [X]$, run
\begin{verbatim}
# dune exec gtypes type-equality type-equality-sample T1 T3
\end{verbatim}
%
It displays towards the end of the printout that
\begin{verbatim}
Types T1 and T3 are unequal
\end{verbatim}
which is a correct result because the right branch of $T_1 [X]$ only sends one
message before possibel termination, while the right branch of $T_3 [X]$ sends
two messages before possible termination.

\subsection{Guide-Type Inference}
